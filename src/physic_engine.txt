    lineObjs = [];
	initialObjPosX = [];
	initialObjSpeedX = [];
	TextObjs = [];
	initialObjSpeedY = [];
	
	lineNameIds.forEach((n) => lineObjs.push(document.getElementById(n)));
	pointNameIds.forEach((n) => initialObjPosX.push(document.getElementById(n)));
	textNames.forEach((n) => TextObjs.push(document.getElementById(n)));
	
	pointNameIds.forEach((n) => initialObjSpeedX.push(0.0));
	pointNameIds.forEach((n) => initialObjSpeedY.push(0.0));
	
	const k_spring = 1;
    const k_repulse = 1;
	const m = 1.5;
	const mu = 2;
	const dt = 0.01;
	const restDistance = 200;
	
	const calculateAcceleration = (fromX, speedX, toXs, isXcoordinate, fromY, toSpringY, repXs, repY) => {
	    displacementForces = [];
        repulsionForces = [];
	    console.log("From: " + Math.abs(fromX), " To's: " +toXs)
		displacement = 0;
		repulsionForce = 0;
		// Springs
	    toXs.forEach((toX, i) => {
			otherLateralPosition = toSpringY[i];
			displacement = 0;
			offsetY = otherLateralPosition-fromY;
			offsetX = toX-fromX;
			degrees = Math.atan2(isXcoordinate ? offsetY : offsetX, isXcoordinate ? offsetX : offsetY)
			actualRestDistance = restDistance * (isXcoordinate ? Math.cos(degrees): Math.sin(degrees))
			console.log("Dis: "+restDistance, "Displacement: " + actualRestDistance, "Deg: "+ degrees * 180 / Math.PI)
			
			if (fromX != toX) {
				displacement = (Math.abs(fromX  - toX) - restDistance)*Math.sign(fromX  - toX) *-1
			} else {
				displacement = 0;
			}

			displacementForces.push(displacement);
	    })
		repulsion = 0;
        // //Repulsion
        repXs.forEach((repX, i)=>{
            repulsion = 0;
			offsetY = repY[i]-fromY;
			offsetX = repX-fromX;
			r = Math.sqrt(repY[i]**2 +  repX**2)
			degrees = Math.atan2(isXcoordinate ? offsetY : offsetX, isXcoordinate ? offsetX : offsetY)
            
            
            if (offsetX === 0){
                repulsion = 0;
            } else {
               repulsion = repX *100 / r**2
            }

            repulsionForces.push(repulsion);
        })


	    
	    springForce = displacementForces.reduce((partialSumForce, otherForce) => partialSumForce + otherForce, 0); 
        repulsionForce = repulsionForces.reduce((partialSumForce, otherForce) => partialSumForce + otherForce, 0); 
	    console.log(springForce, k_repulse*repulsionForce)
		console.log(((k_spring*springForce) + k_repulse*repulsionForce + -1*mu*speedX)/m)
		return ((k_spring*springForce) + k_repulse*repulsionForce + (Math.random()-1)*300 + -1*mu*speedX)/m;
	}
	
	
	var oldPositionsX = [];
	var oldPositionsY = [];
	var oldVelocitiesX = [...initialObjSpeedX];
	var newVelocitiesX = [...initialObjSpeedX];
	
	var oldVelocitiesY = [...initialObjSpeedY];
	var newVelocitiesY = [...initialObjSpeedY];
	var springPointsX = [];
    var springPointsY = [];
	var newAccelerationX, newAccelerationY;
	var newPosX, newPosY;
	var newSpeedX, newSpeedY;
	initialObjPosX.forEach((pointObj, i) =>{
	    oldPositionsX.push((pointObj.getAttribute("x")));
	})
	initialObjPosX.forEach((pointObj, i) =>{
	    oldPositionsY.push((pointObj.getAttribute("y")));
	})
	var newPositionsX = [...oldPositionsX];
	var newPositionsY = [...oldPositionsY];

	let otherPointindex, connections, conntected;
	function animate() {
		console.clear()
	    springPointsX = [];
	    springPointsY = [];
        
	    oldVelocitiesX = [];
	    oldPositionsX = [];
	    oldVelocitiesY = [];
	    oldPositionsY = [];

	    oldVelocitiesX = [...newVelocitiesX];
	    oldPositionsX = [...newPositionsX];
	    oldVelocitiesY = [...newVelocitiesY];
	    oldPositionsY = [...newPositionsY];
	
	    oldPositionsX.forEach((oldPosX, i) =>{
			oldPosY = oldPositionsY[i];
	        parent = pointNameIds[i];
	        springPointsX = [100];
			springPointsY = [100];
	        conntected = []
	        
	        lineNameIds.forEach((name) => {
	            connections = []
	            connections = name.split("_");
	            
	            if (connections[0] === parent) {
	                otherPointindex = pointNameIds.findIndex((randomName)=> (randomName === connections[1]));
	                conntected.push(pointNameIds[otherPointindex]);
	                springPointsX.push(oldPositionsX[otherPointindex]);
					springPointsY.push(oldPositionsY[otherPointindex]);
	            } else if (connections[1] === parent) {
	                otherPointindex = pointNameIds.findIndex((randomName)=> (randomName === connections[0]));
	                conntected.push(pointNameIds[otherPointindex]);
	                springPointsX.push(oldPositionsX[otherPointindex]);
					springPointsY.push(oldPositionsY[otherPointindex]);
	            }
	        })
            
            

	        newAccelerationX = calculateAcceleration(+oldPosX, +oldVelocitiesX[i], springPointsX, true, +oldPosY, springPointsY, oldPositionsX, oldPositionsY);
	        newPosX = +oldPosX + (+oldVelocitiesX[i] * dt);
	        newSpeedX = (+oldVelocitiesX[i] + newAccelerationX * dt);
	        newSpeedX = Math.abs(newSpeedX) > 0.00001 ? newSpeedX : 0;

			newAccelerationY = calculateAcceleration(+oldPosY, +oldVelocitiesY[i], springPointsY, false, +oldPosX, springPointsX,  oldPositionsX, oldPositionsY);
	        newPosY = +oldPosY + (+oldVelocitiesY[i] * dt);
	        newSpeedY = (+oldVelocitiesY[i] + newAccelerationY * dt);
	        newSpeedY = Math.abs(newSpeedY) > 0.00001 ? newSpeedY : 0;
	
	
	        console.log(parent,"AccX:", newAccelerationX, newAccelerationY);
	        console.log(parent,"VelX:", oldVelocitiesX[i], newSpeedX, oldVelocitiesY[i], newSpeedY);
	        console.log(parent,"PosX:", oldPosX, newPosX, oldPosY, newPosY);
	        newPositionsX[i] = (newPosX);
	        newVelocitiesX[i] = newSpeedX;
			newPositionsY[i] = (newPosY);
	        newVelocitiesY[i] = newSpeedY;
	    })
	
	    
	
	    initialObjPosX.forEach((pointObj, i) => {
	        pointObj.setAttribute("x", Math.abs(newPositionsX[i]));
			pointObj.setAttribute("y", Math.abs(newPositionsY[i]));
	    })
	
	    TextObjs.forEach((textObj, i) => {
	        textObj.setAttribute("x", Math.abs(newPositionsX[i])+20);
	        textObj.setAttribute("y", Math.abs(newPositionsY[i])+40);
	    })
	
	    lineNameIds.forEach((name, i) => {
	        connections = name.split("_");
	        lineObjs[i].setAttribute("x1", Math.abs(newPositionsX[pointNameIds.findIndex((name)=> name==connections[0])])+40);
	        lineObjs[i].setAttribute("x2", Math.abs(newPositionsX[pointNameIds.findIndex((name)=> name==connections[1])])+40 );
	        lineObjs[i].setAttribute("y1", Math.abs(newPositionsY[pointNameIds.findIndex((name)=> name==connections[0])])+30);
	        lineObjs[i].setAttribute("y2", Math.abs(newPositionsY[pointNameIds.findIndex((name)=> name==connections[1])])+30 );
	    })
	    
	
	};
	
	var t = null;
	
	function startAnimation() {
	    if(t == null) {
	      t = setInterval(animate, 1);
	    }
	  }
	  
	function stepAnimation(){
	    animate();
	}
	
	function stopAnimation() {
	    if(t != null) {
	        clearInterval(t);
	        t = null;
	    }
	}
